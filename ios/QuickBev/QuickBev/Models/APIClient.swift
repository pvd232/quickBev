//
//  APIClient.swift
//  Drinkz
//
//  Created by Peter Vail Driscoll II on 2/4/21.
//  Copyright Â© 2021 Peter Vail Driscoll II. All rights reserved.
//
import Foundation

enum HTTPMethod: String {
    case get = "GET"
    case put = "PUT"
    case post = "POST"
    case delete = "DELETE"
    case head = "HEAD"
    case options = "OPTIONS"
    case trace = "TRACE"
    case connect = "CONNECT"
}

struct HTTPHeader {
    let field: String
    let value: String
}

class APIRequest {
    let method: HTTPMethod
    let path: String
    var queryItems: [URLQueryItem]?
    var headers: [HTTPHeader]?
    // body property is defined as being an optional data type
    var body: Data?

    init(method: HTTPMethod, path: String) {
        self.method = method
        self.path = path
    }
    // generic type Body is declared outside the init method
    // body has a type constraint, that is must conform to encodable

    init<Body: Encodable>(method: HTTPMethod, path: String, body: Body) throws {
        self.method = method
        self.path = path
        // assign body property to generic type body parameter
        
        self.body = try JSONEncoder().encode(body)
        print("self.body", self.body)
    }
}

// generic type API response with type argument Body, aka the type will be taken in as a parameter and made a concrete type (int, string ect.0 at runtime. it will be assigned to body property
struct APIResponse<Body> {
    let statusCode: Int
    let body: Body
}

// extension on generic type APIResponse when its generic type Body is Data
extension APIResponse where Body == Data? {
    // decode function is a generic instance method with a type argument. takes in new generic type BodyType that has decodable type constraint. the type parameter, BodyType, has it's data type extracted in the parameter
    // this is a throwing function that uses throw keyword to indicate something unexpected happened and to halt execution of function (makes sense when dealing with unknown return values from API call) which will throw an Error Type
    // the return type from this function is the generic type APIResponse with the type parameter BodyType in its generic argument clause
    // when a generic type is listed with the type argument this is effectively a specialized version of the generic type where the <Body> parameter conforms to Decodable
    // to is the external named parameter that the caller of the function will use
    func decode<BodyType: Decodable>(to type: BodyType.Type) throws -> APIResponse<BodyType> {
        // conditional binding to make sure body exists in APIResponse
        guard let data = body else {
            throw APIError.decodingFailure
        }
        // decode the data into the type passed in
        let decodedJSON = try JSONDecoder().decode(BodyType.self, from: data)
        // because there is no initializer declared for the struct, under the hood Swift creates one that takes in parameters to set the property values
        // the API response is generated by the URLSession, and our API response struct is assigned to that value, thus it already has the statusCode embedded into it which is why we can pass it in as an internal property at initialization
        return APIResponse<BodyType>(statusCode: self.statusCode,
                                     body: decodedJSON)
    }
}

enum APIError: Error {
    case invalidURL
    case requestFailed
    case decodingFailure
    case resourceNotFound
}

enum APIResult<Body> {
    case success(APIResponse<Body>)
    case failure(APIError)
}

struct APIClient {
    // closure that takes in generic APIResult enum which can be either success or failure. the enum has a type paramter Body that is specialized to be optional Data,
    // this makes sense because the closure takes in either Data or an error at the bottom here
    typealias APIClientCompletion = (APIResult<Data?>) -> Void

    private let session = URLSession.shared
    private let baseURL = URL(string: "http://127.0.0.1:5000")!

    func perform(_ request: APIRequest, _ completion: @escaping APIClientCompletion) {
        var urlComponents = URLComponents()
        urlComponents.scheme = baseURL.scheme
        if baseURL.port != nil {
            urlComponents.port = baseURL.port
        }
        urlComponents.host = baseURL.host
        urlComponents.path = baseURL.path
        urlComponents.queryItems = request.queryItems

        guard let url = urlComponents.url?.appendingPathComponent(request.path) else {
            completion(.failure(.invalidURL)); return
        }

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = request.method.rawValue
        urlRequest.httpBody = request.body
        if urlRequest.httpBody != nil {
            urlRequest.addValue("application/json", forHTTPHeaderField: "Content-Type")
            urlRequest.addValue("application/json", forHTTPHeaderField: "Accept")

        }
        request.headers?.forEach { urlRequest.addValue($0.value, forHTTPHeaderField: $0.field) }

        let task = session.dataTask(with: urlRequest) { (data, response, error) in
            // this is where the APIResponse is declared using optional binding to downcast the type. the new variable httpResponse is declared and binded to the value of the response on the condition that it is of the type HTTPURLResponse
            guard let httpResponse = response as? HTTPURLResponse else {
                completion(.failure(.requestFailed)); return
            }
            guard let dataResponse = data,
                      error == nil else {
                      debugPrint(error?.localizedDescription ?? "Response Error")
                      return }
                do{
                    //here dataResponse received from a network request
                    let jsonResponse = try JSONSerialization.jsonObject(with:
                                           dataResponse, options: [])
                    debugPrint("jsonResposne", jsonResponse) //Response result
                 } catch let parsingError {
                    debugPrint("Error", parsingError)
                    debugPrint("response",response)
               }

            completion(.success(APIResponse<Data?>(statusCode: httpResponse.statusCode, body: data)))
        }
        task.resume()
    }
}
//struct Post: Decodable {
//    let userId: Int
//    let id: Int
//    let title: String
//    let body: String
//}
//
//let request = APIRequest(method: .get, path: "posts")
//
//APIClient().perform(request) { (result) in
//    switch result {
//    case .success(let response):
//        if let response = try? response.decode(to: [Post].self) {
//            let posts = response.body
//            print("Received posts: \(posts.first?.title ?? "")")
//        } else {
//            print("Failed to decode response")
//        }
//    case .failure:
//        print("Error perform network request")
//    }
//}
